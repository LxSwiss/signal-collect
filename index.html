---
layout: default
title: Home
---
<div class="hero-unit">
	<img class="logo" src="./images/logo.png" align="left">
	<h1>Signal/Collect <g:plusone></g:plusone></h1>
	<p>Allows you to process large graphs in seconds.</p>
	<p class="download-info">
	  <a href="https://github.com/uzh/signal-collect" class="btn btn-primary btn-large">View project on GitHub</a>
	  <a href="downloads/signal-collect-2.0.jar" class="btn btn-large">Download Signal/Collect 2.0</a>
	</p>
</div>

<div class="row">
	<div class="span4">
	   <h2>Fast</h2>
	   <p>Algorithms are automatically executed in parallel to make the most of your CPU cores.</p>
	</p>
	</div>
	<div class="span4">
	  <h2>Scalable</h2>
	  <p>Large graphs can be processed in a matter of seconds.</p>
	</div>
	<div class="span4"> 
	  <h2>Configurable</h2><!-- Dynamic &amp; -->
	  <p>The defaults are chosen to get you started quickly, but everything can be customized.</p>
	</div>
</div>

<!--
      <div class="row">
        <div class="span4">
		   <h2>Scalable</h2>
           <p>Large graphs can be processed on disk.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
        <div class="span4">
          <h2>Modular</h2>
           <p>Multiple vertex and edge types can be added to the same graph.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
        <div class="span4"> 
          <h2>Smart</h2>
          <p>Termination detection is automated.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
      </div>

      <hr>

      <footer>
        <p>&copy; University of Zurich 2012</p>
      </footer>
	  -->

	  <hr class="soften">
          <h2>How it works</h2>
          <p>In Signal/Collect algorithms are written from the perspective of vertices and edges. Once a graph has been specified the edges will <b>signal</b> and the vertices will  <b>collect</b>. When an edge signals it computes a message based on the state of its source vertex. This message is then sent along the edge to the target vertex of the edge. When a vertex collects it uses the received messages to update its state. These operations happen in parallel all over the graph until all messages have been collected and all vertex states have converged.</p>
          <p>Many algorithms have very simple and elegant implementations in Signal/Collect. Please take the time to explore some of the example algorithms below.</p>

	  <hr class="soften">

        <div class="span9 columns">
          <h2>Example Algorithms</h2>
          <!--<p>Click the tabs below to toggle between different algorithms.</p>-->
          <ul id="tab" class="nav nav-tabs">
            <li class="active"><a href="#home" data-toggle="tab">PageRank</a></li>
            <li><a href="#profile" data-toggle="tab">Single-Source Shortest Path</a></li>
          </ul>
          <div id="myTabContent" class="tab-content">
            <div class="tab-pane fade in active" id="home">
<pre class="prettyprint linenums">
import com.signalcollect._

object PageRank extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new PageRankVertex(id=1))
  graph.addVertex(new PageRankVertex(id=2))
  graph.addEdge(new PageRankEdge(sourceId=1, targetId=2))
  graph.addEdge(new PageRankEdge(sourceId=2, targetId=1))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class PageRankVertex(id: Any, dampingFactor: Double=0.85)
    extends DataGraphVertex(id=id, state=1-dampingFactor) {
  type Signal = Double

  def collect(oldState: Double, mostRecentSignals: Iterable[Double]): Double = {
    1 - dampingFactor + dampingFactor * mostRecentSignals.sum
  }
}

class PageRankEdge(sourceId: Any, targetId: Any)
    extends DefaultEdge(sourceId, targetId) {
  type SourceVertex = PageRankVertex

  def signal(sourceVertex: PageRankVertex) = {
    sourceVertex.state * weight / sourceVertex.sumOfOutWeights
  }
}
</pre>
            </div>
            <div class="tab-pane fade" id="profile">
<pre class="prettyprint linenums">
import com.signalcollect._

object SSSP extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new Location(1, Some(0)))
  graph.addVertex(new Location(2))
  graph.addVertex(new Location(3))
  graph.addEdge(new Path(1, 2))
  graph.addEdge(new Path(2, 3))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class Location(id: Any, initialState: Option[Int] = None)
	extends DataGraphVertex(id, initialState) {
  type Signal = Int

  def collect(oldState: State, mostRecentSignals: Iterable[Int]): Option[Int] = {
    val currentShortestPath = oldState.getOrElse(Int.MaxValue)
    Some(mostRecentSignals.reduce(math.min(_, _)))
  }
}

class Path(s: Any, t: Any) extends OptionalSignalEdge(s, t) {
  type SourceVertex = Location

  def signal(sourceVertex: Location) = {
    sourceVertex.state map (_ + weight.toInt)
  }
}
</pre>
            </div>
          </div>