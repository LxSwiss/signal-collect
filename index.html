---
layout: default
title: Home
---
<div class="hero-unit">
	<img class="logo" src="./images/logo.png" align="left">
	<h1>Signal/Collect <g:plusone></g:plusone></h1>
	<p>Allows you to process large graphs in seconds.</p>
	<p class="download-info">
	  <a href="https://github.com/uzh/signal-collect" class="btn btn-large">View project on GitHub</a>
	  <a href="gettingStarted.html" class="btn btn-primary btn-large">Get started with Signal/Collect 2.0</a>
	</p>
</div>

<div class="row">
	<div class="span4">
	   <h2>Fast and Scalable</h2>
	   <p>Algorithms are automatically executed in parallel, which allows you to process huge graphs at lightning speed.</p>
	</p>
	</div>
	<div class="span4">
	  <h2>Easy to use, configurable</h2>
	  <p>Powerful algorithms can be expressed in just a few lines of code. The defaults are chosen to get you started quickly, but everything can be customized.</p>
	</div>
	
</div>
<div class="row">
	<div class="span4"> 
	  <h2>Low-latency, incremental computation</h2><!-- Dynamic &amp; -->
	  <p>Run your algorithms either synchronously or asynchronously and change the graph structure in real-time, without restarting the computation.</p>
	</div>
	<div class="span4"> 
	  <h2>Low-latency, incremental computation</h2><!-- Dynamic &amp; -->
	  <p>Run your algorithms either synchronously or asynchronously and change the graph structure in real-time, without restarting the computation.</p>
	</div>
</div>

<!--
      <div class="row">
        <div class="span4">
		   <h2>Scalable</h2>
           <p>Large graphs can be processed on disk.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
        <div class="span4">
          <h2>Modular</h2>
           <p>Multiple vertex and edge types can be added to the same graph.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
        <div class="span4"> 
          <h2>Smart</h2>
          <p>Termination detection is automated.</p>
          <p><a class="btn" href="#">View details &raquo;</a></p>
        </div>
      </div>

      <hr>

      <footer>
        <p>&copy; University of Zurich 2012</p>
      </footer>
	  -->

	  <hr class="soften">
          <h2>How it works</h2>
          <p>In Signal/Collect algorithms are written from the perspective of vertices and edges. Once a graph has been specified the edges will <b>signal</b> and the vertices will  <b>collect</b>. When an edge signals it computes a message based on the state of its source vertex. This message is then sent along the edge to the target vertex of the edge. When a vertex collects it uses the received messages to update its state. These operations happen in parallel all over the graph until all messages have been collected and all vertex states have converged.</p>
          <p>Many algorithms have very simple and elegant implementations in Signal/Collect. Please take the time to explore some of the example algorithms below.</p>

	  <hr class="soften">

        <div class="span9 columns">
          <h2>Example Algorithms</h2>
          <!--<p>Click the tabs below to toggle between different algorithms.</p>-->
          <ul id="tab" class="nav nav-tabs">
            <li class="active"><a href="#home" data-toggle="tab">PageRank</a></li>
            <li><a href="#profile" data-toggle="tab">Single-Source Shortest Path</a></li>
          </ul>
          <div id="myTabContent" class="tab-content">
            <div class="tab-pane fade in active" id="home">
<pre class="prettyprint linenums">
import com.signalcollect._

object PageRank extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new PageRankVertex(1))
  graph.addVertex(new PageRankVertex(2))
  graph.addEdge(1, new PageRankEdge(2))
  graph.addEdge(2, new PageRankEdge(1))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class PageRankVertex(id: Int, baseRank: Double = 0.15)
    extends DataGraphVertex(id, baseRank) {
  type Signal = Double
  def dampingFactor = 1 - baseRank
  def collect = baseRank + dampingFactor * signals.sum
}

class PageRankEdge(targetId: Int)
    extends DefaultEdge(targetId) {
  type Source = PageRankVertex
  def signal = source.state * weight / source.sumOfOutWeights
}
</pre>
            </div>
            <div class="tab-pane fade" id="profile">
<pre class="prettyprint linenums">
import com.signalcollect._

object SSSP extends App {
  val graph = GraphBuilder.build
  graph.addVertex(new Location(1, Some(0)))
  graph.addVertex(new Location(2))
  graph.addVertex(new Location(3))
  graph.addEdge(1, new Path(2))
  graph.addEdge(2, new Path(3))
  graph.execute
  graph.foreachVertex(println(_))
  graph.shutdown
}

class Location(id: Int, initialState: Option[Int] = None)
	extends DataFlowVertex(id, initialState) {
  type Signal = Int
  def collect(signal: Int) = state match {
    case None                      => Some(signal)
    case Some(currentShortestPath) => Some(math.min(currentShortestPath, signal))
  }
}

class Path(t: Int) extends OptionalSignalEdge(t) {
  def signal = source.state match {
    case None                => None
    case Some(distance: Int) => Some(distance + weight.toInt)
  }
}
</pre>
            </div>
          </div>
