---
layout: default
title: Documentation
group: "navigation"
weight: 2
---
<div class="hero-unit">
  <h1>How things work</h1>
  <p>Explore the fundamental concepts of Signal/Collect</p>
</div>

<h2 id="ProgrammingModel">Programming Model</h2>

<p>The goals of the Signal/Collect programming model are:</p>
<ul>
	<li>Expressive enough to tersely formulate a broad range of graph algorithms</li>
	<li>Can define both synchronous and dataflow-like asynchronous computations</li>
	<li>Straightforward to parallelize/distribute</li>
</ul>

<p>The intuition behind the Signal/Collect programming model is that computations are executed on a graph, where the vertices are the computational units that interact by the means of signals that flow along the edges. This is similar to the actor programming model. All computations in the vertices are accomplished by collecting the incoming signals and then signaling the neighbors in the graph.</p>

<p>This means that every vertex, beyond holding the information about its own id and state, has a collect function which computes the new vertex state based on the old vertex state and the signals that were received.</p>

<pre class="prettyprint lang-scala">class Vertex {
  def collect(oldState: State, uncollectedSignals: Iterable[Signal]): State
}</pre>

<p>Every edge has a reference to its source vertex (if it is attached to one), the id of the target vertex and its weight. It implements a signal function which computes the signal sent along this edge based on its source vertex.</p>

<pre class="prettyprint lang-scala">class Edge {
  def signal(sourceVertex: SourceVertex): Signal
}</pre>

<hr class="soften">

<h2 id="DafaultVertex">Default Vertex Types</h2>

<p>In any Signal/Collect graph different vertices and edges can be freely combined. Usually a vertex is implemented by extending one of the default vertex implementations and an edge is implemented by extending <a href="#DefaultEdge">DefaultEdge</a>. If the default implementations are not memory-efficient enough for a specific purpose, then it is possible to write custom graph elements.</p>

<p>Signal/Collect has two different default vertex implementations:</p>

<p><a href="#DataGraphVertex">DataGraphVertex</a> is suitable for algorithms that iteratively update state associated with vertices and edges. <a href="#DataFlowVertex">DataFlowVertex</a> is suitable for dataflow computations where data is routed through a network of processing vertices. For the user the main noticeable difference between these implementations is how received signals are submitted to the collect function.</p>

<h3 id="DataGraphVertex">DataGraphVertex</h3>
<p>In most iterative computations old values get overridden by newer ones . This is why the collect function of DataGraphVertex receives signals as the parameter mostRecentSignals, which contains only the most recently received signal for each incoming edge that has received at least one signal already.</p>

<h3 id="DataFlowVertex">DataFlowVertex</h3>
<p>In a dataflow computation no signal should ever be lost. This is why the collect function of DataFlowVertex receives a parameter, uncollectedSignals, which contains all the signals that have been received since the collect operation was last executed. The signals are ordered by their time of arrival, oldest signals first. Also, the vertex state is supposed to hold the processed elements and it is automatically reset to a customizable resetState whenever the edges are done with signaling.</p>

<hr class="soften">

<h2 id="DefaultEdge">Default Edge Types</h2>