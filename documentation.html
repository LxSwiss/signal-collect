---
layout: default
title: Documentation
group: "navigation"
weight: 2
---
<div class="hero-unit">
  <h1>How things work</h1>
  <p>Explore the fundamental concepts of Signal/Collect</p>
</div>

<h2 id="ProgrammingModel">Programming Model</h2>

<p>The goals of the Signal/Collect programming model are:</p>
<ul>
	<li>Expressive enough to tersely formulate a broad range of graph algorithms</li>
	<li>Can define both synchronous and dataflow-like asynchronous computations</li>
	<li>Straightforward to parallelize/distribute</li>
</ul>

<p>The intuition behind the Signal/Collect programming model is that computations are executed on a graph, where the vertices are the computational units that interact by the means of signals that flow along the edges. This is similar to the actor programming model. All computations in the vertices are accomplished by collecting the incoming signals and then signaling the neighbors in the graph.</p>

<p>This means that every vertex, beyond holding the information about its own id and state, has a collect function which computes the new vertex state based on the old vertex state and the signals that were received.</p>

<pre class="prettyprint lang-scala">class Vertex {
  def collect(oldState: State, uncollectedSignals: Iterable[Signal]): State
}</pre>

<p>Every edge has a reference to its source vertex (if it is attached to one), the id of the target vertex and its weight. It implements a signal function which computes the signal sent along this edge based on its source vertex.</p>

<pre class="prettyprint lang-scala">class Edge {
  def signal(sourceVertex: SourceVertex): Signal
}</pre>

<hr class="soften">

<h2 id="DafaultVertex">Default Vertex Types</h2>

<p>In any Signal/Collect graph different vertices and edges can be freely combined. Usually a vertex is implemented by extending one of the default vertex implementations and an edge is implemented by extending <a href="#DefaultEdge">DefaultEdge</a>. If the default implementations are not memory-efficient enough for a specific purpose, then it is possible to write custom graph elements.</p>

<p>Signal/Collect has two different default vertex implementations:</p>

<p><a href="#DataGraphVertex">DataGraphVertex</a> is suitable for algorithms that iteratively update state associated with vertices and edges. <a href="#DataFlowVertex">DataFlowVertex</a> is suitable for dataflow computations where data is routed through a network of processing vertices. For the user the main noticeable difference between these implementations is how received signals are submitted to the collect function.</p>

<h3 id="DataGraphVertex">DataGraphVertex</h3>
<p>In most iterative computations old values get overridden by newer ones . This is why the collect function of DataGraphVertex receives signals as the parameter mostRecentSignals, which contains only the most recently received signal for each incoming edge that has received at least one signal already.</p>

<h3 id="DataFlowVertex">DataFlowVertex</h3>
<p>In a dataflow computation no signal should ever be lost. This is why the collect function of DataFlowVertex receives a parameter, uncollectedSignals, which contains all the signals that have been received since the collect operation was last executed. The signals are ordered by their time of arrival, oldest signals first. Also, the vertex state is supposed to hold the processed elements and it is automatically reset to a customizable resetState whenever the edges are done with signaling.</p>

<hr class="soften">

<h2 id="DefaultEdge">Default Edge Types</h2>

<p>Analogous to the <a href="#DafaultVertex">default vertex implementations</a>, Signal/Collect also provides default implementations for edges. Depending on the specific algorithm these edges can directly be used for constructing a graph or provide some predefined functionality and therefore reduce the functionality that needs to be implemented on top of them when creating a new class that extends them.</p>

<p>Three abstract edge implementations exist (the signal functionality needs to be provided on top of them):</p>

<ul>
<li id="DefaultEdge">DefaultEdge is the default edge implementation and provides the basic structure for linking vertices and sending a signal from the source vertex to the target vertex.</li>
<li id="OnlySignalOnChangeEdge">OnlySignalOnChangeEdge extends the default edge implementation but keeps track of the last signal sent and only sends a new signal if the current signal differs from it.</li>
<li id="OptionalSignalEdge">OptionalSignalEdge extends the default edge implementation but requires the signal function to return an Option[_]- type and sends the contained signal if the return differed from None.</li>
</ul>
<p>Edges don't necessarily have to be algorithm specific. Sometimes one of the provided concrete edge implementations can be used without any modifications:</p>

<p>The concrete class StateForwarderEdge, which extends the DefaultEdge abstract class, forwards its current state whenever the signal method is invoked by the source vertex.</p>