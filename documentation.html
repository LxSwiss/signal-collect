---
layout: default
title: Documentation
group: "navigation"
weight: 2
---
<div class="hero-unit">
  <h1>How things work</h1>
  <p>Explore the fundamental concepts of Signal/Collect</p>
</div>

<h2>Programming Model</h2>

<p>The goals of the Signal/Collect programming model are:</p>
<ul>
	<li>Expressive enough to tersely formulate a broad range of graph algorithms</li>
	<li>Can define both synchronous and dataflow-like asynchronous computations</li>
	<li>Straightforward to parallelize/distribute</li>
</ul>

<p>The intuition behind the Signal/Collect programming model is that computations are executed on a graph, where the vertices are the computational units that interact by the means of signals that flow along the edges. This is similar to the actor programming model. All computations in the vertices are accomplished by collecting the incoming signals and then signaling the neighbors in the graph.</p>

<p>This means that every vertex, beyond holding the information about its own id and state, has a collect function which computes the new vertex state based on the old vertex state and the signals that were received.</p>

<pre class="prettyprint lang-scala">class Vertex {
  def collect(oldState: State, uncollectedSignals: Iterable[Signal]): State
}</pre>

<p>Every edge has a reference to its source vertex (if it is attached to one), the id of the target vertex and its weight. It implements a signal function which computes the signal sent along this edge based on its source vertex.</p>

<pre class="prettyprint lang-scala">class Edge {
  def signal(sourceVertex: SourceVertex): Signal
}</pre>